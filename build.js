/**
 * Build Script - HTML & CSS Template Generator
 * 
 * This script:
 * 1. Concatenates CSS modules into main.css
 * 2. Manages HTML head sections centrally
 * 
 * Usage:
 *   node build.js          - Updates CSS and HTML files
 *   node build.js --watch  - Watch mode with auto-rebuild
 *   node build.js --css    - Build CSS only
 *   node build.js --html   - Build HTML only
 * 
 * CSS Structure:
 *   assets/css/src/  - Modular CSS source files
 *   assets/css/main.css - Concatenated production CSS
 */

const fs = require('fs');
const path = require('path');

// ============================================
// CONFIGURATION
// ============================================

const CONFIG = {
  // Site information
  site: {
    name: 'karakayautku4',
    title: 'Utku Karakaya',
    description: 'Software Test Automation Engineer / Python Developer',
    url: 'https://karakayautku4.dev',
    themeColor: '#0d1117',
    favicon: 'https://karakayautku4.dev/favicon.svg',
    ogImage: 'https://karakayautku4.dev/assets/images/profile.webp'
  },
  
  // Person information (for JSON-LD)
  person: {
    name: 'Utku Karakaya',
    jobTitle: 'Software Test Automation Engineer',
    url: 'https://karakayautku4.dev',
    sameAs: [
      'https://github.com/karakayautku4',
      'https://linkedin.com/in/karakayautku4',
      'https://x.com/karakayautku4'
    ]
  },
  
  // File paths
  paths: {
    root: __dirname,
    pages: path.join(__dirname, 'pages'),
    cssSrc: path.join(__dirname, 'assets/css/src'),
    cssOutput: path.join(__dirname, 'assets/css/main.css')
  },
  
  // Fonts
  fonts: {
    preconnect: [
      'https://fonts.googleapis.com',
      'https://fonts.gstatic.com'
    ],
    stylesheet: 'https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap'
  }
};

// ============================================
// CSS BUILD SYSTEM
// ============================================

/**
 * Concatenate CSS files
 * Reads files from src/ folder in order and creates main.css
 */
function buildCSS() {
  console.log('\nBuilding CSS...\n');
  
  const { cssSrc, cssOutput } = CONFIG.paths;
  
  // Check if src folder exists
  if (!fs.existsSync(cssSrc)) {
    console.log(`[!] CSS source folder not found: ${cssSrc}`);
    return false;
  }
  
  // Read CSS files in alphabetical order (01-, 02- prefixes ensure correct order)
  const cssFiles = fs.readdirSync(cssSrc)
    .filter(file => file.endsWith('.css'))
    .sort();
  
  if (cssFiles.length === 0) {
    console.log('[!] No CSS files found in src/ folder');
    return false;
  }
  
  // Generate header
  const header = `/**
 * Main CSS - Auto-generated by build.js
 * 
 * DO NOT EDIT THIS FILE DIRECTLY!
 * Edit the source files in assets/css/src/ instead.
 * 
 * Generated: ${new Date().toISOString()}
 * 
 * TABLE OF CONTENTS
 * =================
${cssFiles.map((file, i) => ` * ${i + 1}. ${file.replace(/^\d+-/, '').replace('.css', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`).join('\n')}
 */

`;
  
  // Combine all files
  let combinedCSS = header;
  
  for (const file of cssFiles) {
    const filePath = path.join(cssSrc, file);
    const content = fs.readFileSync(filePath, 'utf8');
    
    // Add section separator
    const sectionName = file.replace(/^\d+-/, '').replace('.css', '').replace(/-/g, ' ').toUpperCase();
    combinedCSS += `/* ========================================\n`;
    combinedCSS += `   ${sectionName}\n`;
    combinedCSS += `   Source: src/${file}\n`;
    combinedCSS += `   ======================================== */\n\n`;
    combinedCSS += content.trim() + '\n\n';
    
    console.log(`  - ${file}`);
  }
  
  // Add end comment
  combinedCSS += `/* ========================================\n`;
  combinedCSS += `   End of Generated Styles\n`;
  combinedCSS += `   ======================================== */\n`;
  
  // Write to main.css
  fs.writeFileSync(cssOutput, combinedCSS, 'utf8');
  
  console.log(`\n[OK] CSS built: ${cssFiles.length} files -> main.css\n`);
  return true;
}

// ============================================
// PAGE CONFIGURATIONS
// ============================================

const PAGES = {
  'index.html': {
    title: 'karakayautku4',
    description: 'Software Test Automation Engineer / Python Developer',
    canonical: '',
    cssPath: 'assets/css/main.css',
    isRoot: true
  },
  'pages/about.html': {
    title: 'About | karakayautku4',
    description: 'About Utku Karakaya â€” Software Test Automation Engineer / Python Developer, experience and background.',
    canonical: 'pages/about.html',
    cssPath: '../assets/css/main.css',
    isRoot: false,
    includePersonSchema: true
  },
  'pages/projects.html': {
    title: 'Projects | karakayautku4',
    description: 'Python projects, automation tools, and experiments by Utku Karakaya.',
    canonical: 'pages/projects.html',
    cssPath: '../assets/css/main.css',
    isRoot: false
  },
  'pages/workspace.html': {
    title: 'Workspace | karakayautku4',
    description: "Utku Karakaya's workspace, tools, and setup.",
    canonical: 'pages/workspace.html',
    cssPath: '../assets/css/main.css',
    isRoot: false,
    ogTitle: 'Workspace | Utku Karakaya',
    ogDescription: 'My workspace equipment and setup'
  },
  'pages/hobbies.html': {
    title: 'Hobbies | karakayautku4',
    description: "Utku Karakaya's hobbies, interests, and collections.",
    canonical: 'pages/hobbies.html',
    cssPath: '../assets/css/main.css',
    isRoot: false,
    ogTitle: 'Hobbies | Utku Karakaya',
    ogDescription: 'My hobbies and collections'
  },
  'pages/bookmarks.html': {
    title: 'Bookmarks | karakayautku4',
    description: "Utku Karakaya's favorite websites, articles, tools, and resources.",
    canonical: 'pages/bookmarks.html',
    cssPath: '../assets/css/main.css',
    isRoot: false,
    ogTitle: 'Bookmarks | Utku Karakaya',
    ogDescription: 'My favorite websites and resources'
  },
  'pages/pythonleague.html': {
    title: 'PythonLeague | karakayautku4',
    description: 'PythonLeague project by Utku Karakaya',
    canonical: 'pages/pythonleague.html',
    cssPath: '../assets/css/main.css',
    isRoot: false
  },
  'pages/404.html': {
    title: '404 | karakayautku4',
    description: 'Page not found',
    canonical: 'pages/404.html',
    cssPath: '../assets/css/main.css',
    isRoot: false,
    noIndex: true
  }
};

// Sitemap configuration
const SITEMAP_CONFIG = {
  'index.html': { changefreq: 'monthly', priority: 1.0 },
  'pages/about.html': { changefreq: 'monthly', priority: 0.9 },
  'pages/projects.html': { changefreq: 'weekly', priority: 0.9 },
  'pages/workspace.html': { changefreq: 'monthly', priority: 0.8 },
  'pages/hobbies.html': { changefreq: 'monthly', priority: 0.7 },
  'pages/bookmarks.html': { changefreq: 'weekly', priority: 0.7 },
  'pages/pythonleague.html': { changefreq: 'weekly', priority: 0.8 }
  // Note: 404.html and other non-indexed pages excluded from sitemap
};

// ============================================
// TEMPLATE GENERATOR
// ============================================

/**
 * Generate JSON-LD structured data
 */
function generateJsonLD(pageConfig, isHomePage = false) {
  const { site, person } = CONFIG;
  
  // WebSite schema for all pages
  const webSiteSchema = {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": site.title,
    "url": site.url,
    "description": site.description
  };
  
  // Person schema for home and about pages
  const personSchema = {
    "@context": "https://schema.org",
    "@type": "Person",
    "name": person.name,
    "jobTitle": person.jobTitle,
    "url": person.url,
    "sameAs": person.sameAs
  };
  
  if (isHomePage || pageConfig.includePersonSchema) {
    return `<script type="application/ld+json">
${JSON.stringify(webSiteSchema, null, 2)}
  </script>
  <script type="application/ld+json">
${JSON.stringify(personSchema, null, 2)}
  </script>`;
  }
  
  return `<script type="application/ld+json">
${JSON.stringify(webSiteSchema, null, 2)}
  </script>`;
}

/**
 * Generate the <head> content for a page
 */
function generateHead(pageConfig) {
  const { site, fonts } = CONFIG;
  const ogTitle = pageConfig.ogTitle || pageConfig.title.replace(' | karakayautku4', ' | Utku Karakaya');
  const ogDescription = pageConfig.ogDescription || pageConfig.description;
  const canonicalUrl = pageConfig.canonical ? `${site.url}/${pageConfig.canonical}` : `${site.url}/`;
  
  let head = `  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>${pageConfig.title}</title>
  <meta name="description" content="${pageConfig.description}">
  <link rel="canonical" href="${canonicalUrl}">`;

  // Add noindex for 404 page
  if (pageConfig.noIndex) {
    head += `\n  <meta name="robots" content="noindex">`;
  }

  // Open Graph tags
  head += `
  <meta property="og:title" content="${ogTitle}">
  <meta property="og:description" content="${ogDescription}">
  <meta property="og:type" content="website">
  <meta property="og:url" content="${canonicalUrl}">
  <meta property="og:image" content="${site.ogImage}">
  <meta property="og:image:alt" content="Utku Karakaya">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="${site.ogImage}">
  <meta name="theme-color" content="${site.themeColor}">`;

  // Fonts
  head += `
  <link rel="preconnect" href="${fonts.preconnect[0]}">
  <link rel="preconnect" href="${fonts.preconnect[1]}" crossorigin>
  <link href="${fonts.stylesheet}" rel="stylesheet">`;

  // CSS
  head += `
  <link rel="stylesheet" href="${pageConfig.cssPath}">`;

  // Favicon
  head += `
  <link rel="icon" href="${site.favicon}" type="image/svg+xml">`;

  // JSON-LD Structured Data
  const jsonLD = generateJsonLD(pageConfig, pageConfig.isRoot);
  head += `\n  ${jsonLD}`;

  return head;
}

/**
 * Generate skip link HTML
 */
function generateSkipLink() {
  return `<a href="#main-content" class="skip-link">Skip to main content</a>`;
}

/**
 * Update a single HTML file with new head content and skip link
 */
function updateHTMLFile(filePath, pageConfig) {
  const fullPath = path.join(CONFIG.paths.root, filePath);
  
  if (!fs.existsSync(fullPath)) {
    console.log(`[!] File not found: ${filePath}`);
    return false;
  }
  
  let content = fs.readFileSync(fullPath, 'utf8');
  const newHead = generateHead(pageConfig);
  const skipLink = generateSkipLink();
  
  // Replace content between <head> and </head>
  const headRegex = /(<head>)([\s\S]*?)(<\/head>)/i;
  const match = content.match(headRegex);
  
  if (match) {
    content = content.replace(headRegex, `<head>\n${newHead}\n</head>`);
  } else {
    console.log(`[!] Could not find <head> tag in: ${filePath}`);
    return false;
  }
  
  // Add or update skip link after <body...>
  const bodyOpenRegex = /(<body[^>]*>)/i;
  const skipLinkRegex = /<a[^>]*class="skip-link"[^>]*>.*?<\/a>\s*/i;
  
  // Remove existing skip link if present
  content = content.replace(skipLinkRegex, '');
  
  // Add skip link after body tag
  const bodyMatch = content.match(bodyOpenRegex);
  if (bodyMatch) {
    content = content.replace(bodyOpenRegex, `$1\n  ${skipLink}`);
  }
  
  // Ensure main has id="main-content"
  if (!content.includes('id="main-content"')) {
    // Add id to first <main> tag if it exists
    content = content.replace(/<main([^>]*)>/i, '<main$1 id="main-content">');
  }
  
  fs.writeFileSync(fullPath, content, 'utf8');
  console.log(`[OK] Updated: ${filePath}`);
  return true;
}

/**
 * Get today's date in YYYY-MM-DD format
 */
function getTodayDate() {
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Build sitemap.xml with current date
 */
function buildSitemap() {
  const site = CONFIG.site;
  const today = getTodayDate();
  
  let sitemap = '<?xml version="1.0" encoding="UTF-8"?>\n';
  sitemap += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
  
  // Add each page to sitemap
  for (const [filePath, config] of Object.entries(SITEMAP_CONFIG)) {
    const url = filePath === 'index.html' 
      ? site.url 
      : `${site.url}/${filePath}`;
    
    sitemap += `  <url>\n`;
    sitemap += `    <loc>${url}</loc>\n`;
    sitemap += `    <lastmod>${today}</lastmod>\n`;
    sitemap += `    <changefreq>${config.changefreq}</changefreq>\n`;
    sitemap += `    <priority>${config.priority}</priority>\n`;
    sitemap += `  </url>\n`;
  }
  
  sitemap += '</urlset>\n';
  
  const sitemapPath = path.join(CONFIG.paths.root, 'sitemap.xml');
  fs.writeFileSync(sitemapPath, sitemap, 'utf8');
  console.log(`[OK] Sitemap generated with date: ${today}`);
  return true;
}

/**
 * Build all HTML files
 */
function buildHTML() {
  console.log('\nBuilding HTML files...\n');
  
  let successCount = 0;
  let failCount = 0;
  
  for (const [filePath, config] of Object.entries(PAGES)) {
    if (updateHTMLFile(filePath, config)) {
      successCount++;
    } else {
      failCount++;
    }
  }
  
  console.log(`\n[OK] HTML build complete: ${successCount} success, ${failCount} failed\n`);
}

/**
 * Full build - CSS, HTML, and Sitemap
 */
function build() {
  console.log('\nStarting full build...');
  buildCSS();
  buildHTML();
  buildSitemap();
  console.log('Build complete!\n');
}

/**
 * Watch mode - rebuild on file changes
 */
function watch() {
  console.log('\nWatching for changes...\n');
  
  // Initial build
  build();
  
  // Watch build.js for config changes
  fs.watch(__filename, () => {
    console.log('\nConfig changed, rebuilding...');
    delete require.cache[require.resolve(__filename)];
    build();
  });
  
  // Watch CSS src folder
  const cssSrcPath = CONFIG.paths.cssSrc;
  if (fs.existsSync(cssSrcPath)) {
    fs.watch(cssSrcPath, (eventType, filename) => {
      if (filename && filename.endsWith('.css')) {
        console.log(`\nCSS changed: ${filename}, rebuilding CSS...`);
        buildCSS();
      }
    });
  }
  
  console.log('Press Ctrl+C to stop.\n');
}

// ============================================
// CLI
// ============================================

const args = process.argv.slice(2);

if (args.includes('--watch') || args.includes('-w')) {
  watch();
} else if (args.includes('--css')) {
  buildCSS();
} else if (args.includes('--html')) {
  buildHTML();
} else if (args.includes('--help') || args.includes('-h')) {
  console.log(`
Build Script - CSS, HTML, & Sitemap Generator

Usage:
  node build.js           Full build (CSS + HTML + Sitemap)
  node build.js --css     Build CSS only
  node build.js --html    Build HTML only
  node build.js --watch   Watch mode (rebuild on changes)
  node build.js --help    Show this help message

CSS Build:
  Combines all CSS files from assets/css/src/ into assets/css/main.css
  Files are processed in alphabetical order (use 01-, 02- prefixes)

HTML Build:
  Updates <head> section of all HTML files with consistent meta tags,
  fonts, stylesheets, and JSON-LD structured data.

Sitemap Build:
  Generates sitemap.xml with all pages and today's date.
  Updates automatically on every full build.
`);
} else {
  build();
}
